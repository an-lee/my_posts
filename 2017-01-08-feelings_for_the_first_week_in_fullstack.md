---
title: 全栈营第一周学习体会
categories: fullstack
tags:
  - ORID
---

全栈营正式开课第一周，学习过程不算太顺利，但是收获确实是匪浅。

首先就是 Xdite 老师的直播，为我讲解了全栈工程师所应该具备的能力，使得我对「全栈」这个概念有了更清晰的理解（见[怎样才算得上是全栈工程师](http://an-lee.logdown.com/posts/2017/01/04/1271828)）。

接下来对教材的学习也有非常大的收获。

# 拆解任务

当我们产生一个 idea 的时候，通常都是脑子里各种奇思妙想在短时间内喷涌而出，而这些奇思妙想冒出来的时候是「无序」的，这种状态更形象的说法是 brainstrom，根本无暇顾及新冒出来的这些想法是否合理、是否有逻辑，也根本无需去顾及，因为 brainstorm 的目的就是更多的产生「想法」而已。

我在跟着教程，回想自己每天早上起来后做的每一件事，用便签条逐一纪录下来时，就有这种 brainstorm 的感觉。一张便签一个想法，可以让 ideas 流畅地往外涌。

当我们有了一堆想法之后，下一步就是将这些想法整理分类，这其实是拆解的**关键步骤**。写在便签上的每一个事项，并不是等同重要的，这个时候我们就要根据自己的实际情况或者偏好，将这些便签分类。教程中提供了一个很好的分类模板：

- Must have
- Should have
- Could have
- Nice to have

这样归类以后，我们接下来的工作就会变得更有条理性了。先把必须要做的 Must have 完成，然后接着是 Should have，接着是 Could have，最后还有余力，才是 Nice to have。这样避免了我们在做事情时本末倒置。

其实这样的方法对我来说并不陌生，我自己每天在印象笔记里写任务时，采用的就是这样的方法，不过我只分了3类，分别是

- Big rocks
- Must-dos
- Like-to-dos

Big rocks 是一天中最重要的事情，优先级最高，通常是当天必须完成的工作任务。然后是 Must-dos，优先级次之，最后是 Like-to-dos。这样把任务分类之后，除了使得自己的工作顺序变得更条理，还有一个好处，那就是避免一天下来，自己的列任务表一项都没完成，或者只完成了一点点时产生的挫败感。

我们在列任务时总是倾向于高估自己，早上很容易列出一大堆任务来了，到了晚上发现能完成的了了无几。在列任务时，所谓的 big rocks 是真正重要的事情，所以一定不会太多，通常是只有1~2件，而其实我一天的主要任务就是把 big rocks 消灭掉，只要完成了 big rocks，其他的未完成任务再多，我也知道我今天过得已经非常充实。

回到编程中的拆解任务，如果我们不把待开发功能归好类，那么在实际开发过程中，就会成为无头苍蝇。通常的情况可能是，我们会先把容易做的功能先做了，把难的功能先放一边。造成的结果可能就是，时限到的时候，只完成了一大堆小功能，但真正重要的功能却没有完成，导致整个程序跑不起来。换句话说，就是白忙乎一阵，却没有**成品**。

成品特别重要，是我们所有工作的一个集中体现。只有至少当 Must have 的功能完成了，才有可能支撑起一个**成品**。所谓成品，其实是实现了一个从0到1的过程。成品并不需要完美，事实上也不可能完美，但是如果没有成品，不管做了多少其他工作，都是0分，没有过程分。

# 用户故事

用户故事（User story）这个概念对我来说是震撼的，不但把程序的功能更有条理性地的贯穿起来，更重要的是，这种思考模式，会使得开发人员更有「**代入感**」，在开发时用不同使用者的「角色」去思考和体会其各自不同的需求，和可能遭遇的体验。

用户故事的核心是

> 某人(角色)做某事(故事)，产生了某种效果

再回想自己的经验，我在工作中也曾经写过一些 VBA 的小程序，用以提高自己的工作效率。整个思路是这样的，

> 我在工作中遇到了一些需要不断重复的工作，我希望可以让这些重复工作自动完成。于是，我从这个需求入手，编写一些代码，满足了这个需求。

这样的开发过程，其实是最简单的，因为只有一个角色，那就是我自己。一个人的故事再复杂也有限。

一旦角色多了，可能产生的故事就更多更复杂了，可以让人浮想联翩。从这个角度来看，单机软件因为只有一个用户，角色单一，仅仅是一个工具而已。

而网络程序或者网站就不同了，因为聚集着非常多的用户，角色丰富多样，角色与角色之间的连结交错紧密，**写一个网络程序简直就像写一部小说一样**，其本质就是编写各个角色之间发生的故事。

好的小说，不光故事情节要精彩，各个人物的刻画也是生动形象；好的程序就像好的小说一样，不光功能要完善，用户体验也要一级棒才行。

# 拼图的快感

全栈营正式开课之前，我把教程的中级训练 Rails 101 做了5遍，前3遍严格按照教程的要求，第一遍复制粘贴，第二遍照着打，第三遍看解释，在过程中遇到的错误和解决办法也都记录了下来。

在第4遍的时候，我不光是把解释再看一遍，而且把一些我新领悟到的知识总结了下来，一些我仍然不理解的知识，我也记录了下来，还附上了我自己的「猜想」（[Rails101第2章笔记](http://an-lee.logdown.com/posts/2016/12/25/1242264)，[Rails101第3章笔记](http://an-lee.logdown.com/posts/2016/12/26/1243682)，[Rails101第4章笔记](http://an-lee.logdown.com/posts/2016/12/27/1247565)，[Rails101第5章笔记](http://an-lee.logdown.com/posts/2016/12/28/1250103)，[Rails101第6章笔记](http://an-lee.logdown.com/posts/2016/12/30/1255892)，[Rails101第7章笔记](http://an-lee.logdown.com/posts/2016/12/30/1255976)，[Rails101第8章笔记](http://an-lee.logdown.com/posts/2016/12/31/1260021)，[Rails101第9章笔记](http://an-lee.logdown.com/posts/2016/12/31/1260196)）。这些理解不一定完全正确，事实上不可能完全正确，但由于我试图理解的这个过程，使得我与知识更靠近了一步。

在做这一周的招聘网站时，明显体会到自己对教材的理解能力有提高，之前的部分「猜想」也得到了证实。

真的就好像在拼图，看到一些疑似的图块，虽然不肯定是不是对，但也先把它找个位置放进去，继续往前走，去找更多的图块。当找到更好的图块时，再把之前的换下来。

# 学习时间

我白天要上班，晚上要帮忙照顾3个月的儿子，我的学习时间安排在每天早上的4点半~6点半。在正式开课之后，明显感觉时间不够用。

但其实，学习不一定局限在敲代码的时候，其余不在电脑前时，我们依然可以通过其他方法来巩固学习。

今天上午我有事情外出，要在外面等3个小时。在空闲的时候，我就拿出笔记本，做提取练习，把招聘网站的建设思路整理了一遍。然后用手机上全栈营主页，把教程再通看了一遍。下午回家敲代码时，就变得顺利很多。

另外，我在公司时，不忙的时候，我就写 ORID，把自己早上做的事情回想一遍。我们无法保证学习的环境是完美的，但是我们应该训练自己在不同的环境下都能高效学习的能力。

# 最重要的是往前走

本周正式开课之后的前两天，我遇上了[几个非常诡异的 bug](http://an-lee.logdown.com/posts/2017/01/06/1278204)，一直卡在最开始的几步。

我自己在排 bug 的时候，先检查了每一步骤，逐行对比了代码，还是检查不出问题，然后直接将教程上的代码复制粘贴，这个时候通常能解决问题。

但是前几天，我已经是每一步都复制粘贴，还是出现错误，如此重复了无数次。时间就这么过去了，而进度一点没有往前。

因为我实作的时候通常是在清晨（0430~0630），这个时候没有助教值班，Google 没找到合适答案的时候，也没有其他的求助渠道，心情会瞬间变得急躁。这个状态下，排 bug 简直是难上加难。有时候因为一个看似很小的错误，卡着不能继续，一天的时间就这么过去了。

这让我想起「如何自救」的第5个问题：

> 这个问题卡住的话，会让我接下来无法继续下去吗？

当答案是肯定的时候，这个问题就会是一个**巨大的坑**。这个时候，我告诉自己，我的**焦点应该转移**了，应该从「如何把这个问题解决」转到「如何绕过这个问题**继续下去**」。

光盯着问题本身是找不到解决办法的，也容易让我们忘记真正的目标。我们的首要目标始终是**把事情做出来**，而不是一次过把所有问题解决。先把事情做出来，有了成品，再更新迭代。

在我的本职工作中，其实也是这样的，做项目就是利用**有限的资源**，在**有限的时间**里，**把事情做完**。时间是有限的，资源是有限的，但我们的最终目标是把事情做完。遇到暂时无法解决的问题，如果不阻碍项目进程，就先放一边；如果是阻碍项目继续的问题，又暂时找不到解决方法，就必须千方百计绕过去。

所以，当我意识到自己掉进大坑里的时候，第二天，我就不再排 bug 了，而是把错误记录下来，然后把整个专案删除，重新再来。继续往前走是更重要的。

事后证明，我的选择是正确的。后来我在 Slack 上发现了也有别的同学提问了跟我类似的问题，比如说这个：

```
File to import not found or unreadable: bootstrap-sprockets.
```

所有的步骤和拼写都没正确，这个错误依旧存在。助教给出的答案是

> 主要原因是 bootstrap 没有安装成功
>
> bundle install 重新安装一遍

我想，即使我花再多的时间，可能也想不到原因竟然是这个。幸亏，那时我先把问题绕过去了；幸亏，我还把问题记录了下来。

# 不断完善代码

教程中的步骤编排得非常有特点，要实现某个功能，教程并不是直接给出了最优解，而是先给出了一个最简单但是低效的方法，然后再一步一步地进行优化，最后才给出最「牛逼」的代码。

这其实是在是培养我们的写代码的一种思维方法，将一样的功能实现出来，可以有非常多种的方式，但是最直接的方法往往不是最好的方法。

我们必须要有全局观，要考虑到将来可能会有哪些变化，我现在的代码如何来适应将来可能出现的变化。也就是说，代码是需要管理的，要有前瞻性。用一些看似「迂回」的方法实现一个简单地功能，在当下针对一个小功能来看可能是比较复杂，但考虑到以后项目变大，代码越来越多，这样带有结构性的代码会更具有管理性。
